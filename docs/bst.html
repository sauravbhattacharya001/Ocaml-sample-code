<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Search Tree — OCaml Sample Code</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <nav class="sidebar">
        <div class="sidebar-header"><a href="index.html" class="logo">?? OCaml Samples</a></div>
        <div class="nav-section">
            <div class="nav-title">Getting Started</div>
            <a href="index.html" class="nav-link">Overview</a>
            <a href="setup.html" class="nav-link">Installation</a>
            <a href="learning-path.html" class="nav-link">Learning Path</a>
        </div>
        <div class="nav-section">
            <div class="nav-title">Examples</div>
            <a href="hello.html" class="nav-link">?? Hello OCaml</a>
            <a href="list-last.html" class="nav-link">?? Last Element</a>
            <a href="factor.html" class="nav-link">?? Factorization</a>
            <a href="bst.html" class="nav-link active">?? Binary Search Tree</a>
            <a href="mergesort.html" class="nav-link">?? Merge Sort</a>
            <a href="fibonacci.html" class="nav-link">?? Fibonacci</a>
            <a href="graph.html" class="nav-link">??? Graph Algorithms</a>
            <a href="heap.html" class="nav-link">?? Priority Queue</a>
            <a href="parser.html" class="nav-link">ðŸ§© Parser Combinators</a>
            <a href="trie.html" class="nav-link">ðŸ”¤ Trie (Prefix Tree)</a>
        </div>
        <div class="nav-section">
            <div class="nav-title">Reference</div>
            <a href="concepts.html" class="nav-link">Concept Index</a>
            <a href="https://github.com/sauravbhattacharya001/Ocaml-sample-code" class="nav-link external">GitHub ?</a>
        </div>
    </nav>

    <main class="content">
        <div class="container">
            <div class="example-header">
                <span class="icon">??</span>
                <h1>Binary Search Tree</h1>
            </div>
            <p><strong>File:</strong> <a href="https://github.com/sauravbhattacharya001/Ocaml-sample-code/blob/master/bst.ml"><code>bst.ml</code></a></p>
            <div class="example-meta">
                <span class="concept-badge">algebraic data types</span>
                <span class="concept-badge">pattern matching</span>
                <span class="concept-badge">recursion</span>
                <span class="concept-badge">accumulators</span>
                <span class="concept-badge">polymorphism</span>
            </div>

            <section>
                <h2>Overview</h2>
                <p>Full BST implementation using algebraic data types — insert, delete (with in-order successor replacement), membership check, min/max, in-order traversal, size, and depth. The <code>'a</code> type parameter means this tree works with integers, strings, or any comparable type.</p>
            </section>

            <section>
                <h2>Type Definition</h2>
                <p>Model a tree in 3 lines — this is where OCaml shines:</p>
                <pre><code><span class="kw">type</span> <span class="type">'a tree</span> =
  <span class="op">|</span> <span class="type">Leaf</span>
  <span class="op">|</span> <span class="type">Node</span> <span class="kw">of</span> <span class="type">'a tree</span> * <span class="type">'a</span> * <span class="type">'a tree</span></code></pre>
            </section>

            <section>
                <h2>Key Operations</h2>

                <h3>Insert</h3>
                <pre><code><span class="kw">let</span> <span class="kw">rec</span> <span class="fn">insert</span> x = <span class="kw">function</span>
  <span class="op">|</span> <span class="type">Leaf</span> <span class="op">-></span> <span class="type">Node</span> (<span class="type">Leaf</span>, x, <span class="type">Leaf</span>)
  <span class="op">|</span> <span class="type">Node</span> (left, v, right) <span class="op">-></span>
    <span class="kw">if</span> x &lt; v <span class="kw">then</span> <span class="type">Node</span> (<span class="fn">insert</span> x left, v, right)
    <span class="kw">else if</span> x > v <span class="kw">then</span> <span class="type">Node</span> (left, v, <span class="fn">insert</span> x right)
    <span class="kw">else</span> <span class="type">Node</span> (left, v, right)  <span class="cmt">(* duplicate: no change *)</span></code></pre>

                <h3>In-Order Traversal (O(n) with Accumulator)</h3>
                <p>The accumulator pattern avoids O(n) list concatenation at each node, giving O(n) overall instead of O(n²):</p>
                <pre><code><span class="kw">let</span> <span class="fn">inorder</span> tree =
  <span class="kw">let</span> <span class="kw">rec</span> <span class="fn">aux</span> acc = <span class="kw">function</span>
    <span class="op">|</span> <span class="type">Leaf</span> <span class="op">-></span> acc
    <span class="op">|</span> <span class="type">Node</span> (left, v, right) <span class="op">-></span>
      <span class="fn">aux</span> (v <span class="op">::</span> <span class="fn">aux</span> acc right) left
  <span class="kw">in</span> <span class="fn">aux</span> [] tree</code></pre>

                <h3>Delete (with In-Order Successor)</h3>
                <p>Deleting a node with two children: replace it with the smallest value in the right subtree (the in-order successor), then delete that successor from the right subtree:</p>
                <pre><code><span class="kw">let</span> <span class="kw">rec</span> <span class="fn">delete</span> x = <span class="kw">function</span>
  <span class="op">|</span> <span class="type">Leaf</span> <span class="op">-></span> <span class="type">Leaf</span>
  <span class="op">|</span> <span class="type">Node</span> (left, v, right) <span class="op">-></span>
    <span class="kw">if</span> x &lt; v <span class="kw">then</span> <span class="type">Node</span> (<span class="fn">delete</span> x left, v, right)
    <span class="kw">else if</span> x > v <span class="kw">then</span> <span class="type">Node</span> (left, v, <span class="fn">delete</span> x right)
    <span class="kw">else match</span> left, right <span class="kw">with</span>
      <span class="op">|</span> <span class="type">Leaf</span>, _ <span class="op">-></span> right
      <span class="op">|</span> _, <span class="type">Leaf</span> <span class="op">-></span> left
      <span class="op">|</span> _ <span class="op">-></span>
        (<span class="kw">match</span> <span class="fn">min_elem</span> right <span class="kw">with</span>
         <span class="op">|</span> <span class="type">None</span> <span class="op">-></span> <span class="type">Leaf</span>
         <span class="op">|</span> <span class="type">Some</span> s <span class="op">-></span> <span class="type">Node</span> (left, s, <span class="fn">delete</span> s right))</code></pre>
            </section>

            <section>
                <h2>Output</h2>
                <div class="output-block">
                    <pre>In-order: 1 3 4 5 6 7 8
Contains 4: true
Contains 9: false
Depth: 3
Size: 7
Minimum: 1
Maximum: 8
After deleting 3: 1 4 5 6 7 8
Contains 3 after delete: false</pre>
                </div>
            </section>

            <div class="nav-arrows">
                <a href="factor.html" class="nav-arrow">? Factorization</a>
                <a href="mergesort.html" class="nav-arrow">Next: Merge Sort ?</a>
            </div>

            <footer>
                <p><a href="https://github.com/sauravbhattacharya001/Ocaml-sample-code">View on GitHub</a> · MIT License</p>
            </footer>
        </div>
    </main>
</body>
</html>
