<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Learning Path — OCaml Sample Code</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <nav class="sidebar">
        <div class="sidebar-header">
            <a href="index.html" class="logo">?? OCaml Samples</a>
        </div>
        <div class="nav-section">
            <div class="nav-title">Getting Started</div>
            <a href="index.html" class="nav-link">Overview</a>
            <a href="setup.html" class="nav-link">Installation</a>
            <a href="learning-path.html" class="nav-link active">Learning Path</a>
        </div>
        <div class="nav-section">
            <div class="nav-title">Examples</div>
            <a href="hello.html" class="nav-link">?? Hello OCaml</a>
            <a href="list-last.html" class="nav-link">?? Last Element</a>
            <a href="factor.html" class="nav-link">?? Factorization</a>
            <a href="bst.html" class="nav-link">?? Binary Search Tree</a>
            <a href="mergesort.html" class="nav-link">?? Merge Sort</a>
            <a href="fibonacci.html" class="nav-link">?? Fibonacci</a>
            <a href="graph.html" class="nav-link">??? Graph Algorithms</a>
            <a href="heap.html" class="nav-link">?? Priority Queue</a>
            <a href="parser.html" class="nav-link">ðŸ§© Parser Combinators</a>
            <a href="trie.html" class="nav-link">ðŸ”¤ Trie (Prefix Tree)</a>
        </div>
        <div class="nav-section">
            <div class="nav-title">Reference</div>
            <a href="concepts.html" class="nav-link">Concept Index</a>
            <a href="https://github.com/sauravbhattacharya001/Ocaml-sample-code" class="nav-link external">GitHub ?</a>
        </div>
    </nav>

    <main class="content">
        <div class="container">
            <h1>?? Learning Path</h1>
            <p>A guided order for studying the examples. Each stage builds on concepts from the previous one.</p>

            <section>
                <div class="stage">
                    <div class="stage-number">Stage 1 — Foundations</div>
                    <h3><a href="hello.html">hello.ml</a> — Start Here</h3>
                    <p>OCaml infers types without annotations. The pipe operator chains transformations left-to-right, making data pipelines readable. No semicolons, no type declarations, no <code>return</code> keyword.</p>
                    <div class="example-meta">
                        <span class="concept-badge">let bindings</span>
                        <span class="concept-badge">type inference</span>
                        <span class="concept-badge">pipe operator</span>
                        <span class="concept-badge">Printf</span>
                    </div>
                </div>

                <div class="stage">
                    <div class="stage-number">Stage 2 — Core Patterns</div>
                    <h3><a href="list-last.html">list_last_elem.ml</a> — Safe List Traversal</h3>
                    <p>OCaml uses <code>Option</code> instead of null. Pattern matching replaces <code>if/else</code> chains and is exhaustive — the compiler warns if you miss a case.</p>
                    <div class="example-meta">
                        <span class="concept-badge">option types</span>
                        <span class="concept-badge">pattern matching</span>
                        <span class="concept-badge">recursion</span>
                    </div>

                    <h3><a href="factor.html">factor.ml</a> — Recursive Algorithms</h3>
                    <p>Mutually recursive functions with <code>let rec ... and ...</code> — a natural way to express multi-phase algorithms. Shows input validation without exceptions in the happy path.</p>
                    <div class="example-meta">
                        <span class="concept-badge">recursion</span>
                        <span class="concept-badge">mutual recursion</span>
                        <span class="concept-badge">input validation</span>
                    </div>
                </div>

                <div class="stage">
                    <div class="stage-number">Stage 3 — Data Structures</div>
                    <h3><a href="bst.html">bst.ml</a> — Algebraic Data Types</h3>
                    <p>This is where OCaml shines. Model tree structures in 3 lines with algebraic data types. The <code>'a</code> polymorphism means the tree works with any type. The accumulator pattern in <code>inorder</code> converts O(n²) to O(n).</p>
                    <div class="example-meta">
                        <span class="concept-badge">algebraic data types</span>
                        <span class="concept-badge">polymorphism</span>
                        <span class="concept-badge">accumulators</span>
                    </div>
                </div>

                <div class="stage">
                    <div class="stage-number">Stage 4 — Higher-Order Functions</div>
                    <h3><a href="mergesort.html">mergesort.ml</a> — Functions as Arguments</h3>
                    <p>Passing functions as arguments makes code reusable. Tail recursion makes it production-ready. Both <code>split</code> and <code>merge</code> are tail-recursive to handle large inputs without stack overflow.</p>
                    <div class="example-meta">
                        <span class="concept-badge">higher-order functions</span>
                        <span class="concept-badge">tail recursion</span>
                        <span class="concept-badge">polymorphism</span>
                    </div>
                </div>

                <div class="stage">
                    <div class="stage-number">Stage 5 — Imperative OCaml</div>
                    <h3><a href="fibonacci.html">fibonacci.ml</a> — Mutable State When You Need It</h3>
                    <p>OCaml lets you use mutable state locally while keeping your public API pure. Closures encapsulate the hash table cache, making it invisible to the outside world. Demonstrates that choosing the right approach matters more than micro-optimization.</p>
                    <div class="example-meta">
                        <span class="concept-badge">hash tables</span>
                        <span class="concept-badge">closures</span>
                        <span class="concept-badge">memoization</span>
                        <span class="concept-badge">benchmarking</span>
                    </div>
                </div>
            </section>

            <section>
                <h2>What's Next?</h2>
                <ol class="steps">
                    <li><strong>Modify an example</strong> — Add <code>find</code> to the BST, or make merge sort stable</li>
                    <li><strong>Write a new one</strong> — Implement a stack, queue, or graph traversal</li>
                    <li><strong>Read the manual</strong> — <a href="https://ocaml.org/docs">OCaml.org docs</a> cover modules, functors, and the standard library</li>
                    <li><strong>Try Real World OCaml</strong> — <a href="https://dev.realworldocaml.org/">dev.realworldocaml.org</a> for production patterns</li>
                </ol>
            </section>

            <footer>
                <p>
                    <a href="https://github.com/sauravbhattacharya001/Ocaml-sample-code">View on GitHub</a>
                    · MIT License ·
                    Built by <a href="https://github.com/sauravbhattacharya001">Saurav Bhattacharya</a>
                </p>
            </footer>
        </div>
    </main>
</body>
</html>
